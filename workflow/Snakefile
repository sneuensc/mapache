"""
Author: Samuel Neuenschwander, Diana Ivette Cruz, Lucas Anchieri, Anna-Sapfo Malaspinas 
Affiliation: DBC, UNIL
Aim: Map ancient DNA libraries to a reference GENOMES
Date: 28/10/2019
"""


##########################################################################################
import logging

LOGGER = logging.getLogger("snakemake.logging")
# logging.basicConfig(filename="example.log", encoding="utf-8", level=logging.DEBUG)
# logging.basicConfig(format="%(levelname)s %(message)s")


## read the config file
configfile: "config/config.yaml"


include: "scripts/utils.py"
include: "rules/common.smk"


RESULT_DIR = recursive_get(["result_dir"], "results")

## the file is executed for each session: be verbose only in the first one (use a file as flag)
fileVerbose = pathlib.Path(f"{RESULT_DIR}/verbose.touch")
if not fileVerbose.is_file():
    fileVerbose.parent.mkdir(parents=True, exist_ok=True)
    fileVerbose.touch()
    VERBOSE = recursive_get(["VERBOSE"], True)
else:
    VERBOSE = False


## retry failed jobs
memory_increment_ratio = float(recursive_get(["memory_increment_ratio"], 1))
runtime_increment_ratio = float(recursive_get(["runtime_increment_ratio"], 0))

## software versions
module_samtools = recursive_get(["envmodules", "samtools"], "")
module_bowtie2 = recursive_get(["envmodules", "bowtie2"], "")
module_bwa = recursive_get(["envmodules", "bwa"], "")
module_picard = recursive_get(["envmodules", "picard"], "")
module_gatk3 = recursive_get(["envmodules", "gatk3"], "")
module_fastqc = recursive_get(["envmodules", "fastqc"], "")
module_r = recursive_get(["envmodules", "r"], "")
module_adapterremoval = recursive_get(["envmodules", "adapterremoval"], "")
module_mapdamage = recursive_get(["envmodules", "mapdamage"], "")
module_bedtools = recursive_get(["envmodules", "bedtools"], "")
module_seqtk = recursive_get(["envmodules", "seqtk"], "")
module_qualimap = recursive_get(["envmodules", "qualimap"], "")
module_multiqc = recursive_get(["envmodules", "multiqc"], "")
module_dedup = recursive_get(["envmodules", "dedup"], "")
module_glimpse = recursive_get(["envmodules", "glimpse"], "")
module_bcftools = recursive_get(["envmodules", "bcftools"], "")


##########################################################################################
## REFERENCE GENOME
##########################################################################################
## is at least a reference GENOMES defined
GENOMES = list(recursive_get(["genome"], ""))
if len(GENOMES) == 0:
    LOGGER.error("ERROR: Reference genome is not specified (parameter config[genome])!")
    os._exit(1)

## get all chromosome names and store them in the dict config[chromosomes][genome][all] for later use
for genome in GENOMES:
    set_chromosome_names(genome)


##########################################################################################
## SAMPLES (sample file and external bam files)
##########################################################################################
# sample_file="config/SAMPLES.tsv"
SAMPLES, PAIRED_END, COLLAPSE, SAMPLE_FILE = read_sample_file()

## get SAMPLES (bam files) to compute only stats on them
EXTERNAL_SAMPLES, EXTERNAL_SAMPLE_FILE = get_external_samples()

if len(SAMPLES) + len(EXTERNAL_SAMPLES) == 0:
    LOGGER.error(f"ERROR: No samples are specified)!")
    sys.exit(1)

wildcard_constraints:
    sm = "|".join([sm for sm in SAMPLES] + [sm for gen in EXTERNAL_SAMPLES for sm in EXTERNAL_SAMPLES[gen]]),
    genome = "|".join([g for g in GENOMES]),

##########################################################################################
##  WORKFLOW
##########################################################################################
## --------------------------------------------------------------------------------------------------
## subsampling
run_subsampling = str2bool(
    recursive_get_and_test(["subsampling", "run"], ["False", "True"])
)
subsampling_number = float(recursive_get(["subsampling", "number"], 0))
if subsampling_number == 0:
    run_subsampling = False

## --------------------------------------------------------------------------------------------------
## adapterremoval
run_adapter_removal = str2bool(
    recursive_get_and_test(["adapterremoval", "run"], ["True", "False"])
)

## --------------------------------------------------------------------------------------------------
## mapping
mapper = recursive_get_and_test(
    ["mapping", "mapper"], ["bwa_aln", "bwa_mem", "bowtie2"]
)

## --------------------------------------------------------------------------------------------------
## filtering
run_filtering = str2bool(
    recursive_get_and_test(["filtering", "run"], ["True", "False"])
)

if run_filtering:
    save_low_qual = str2bool(
        recursive_get_and_test(["filtering", "save_low_qual"], ["True", "False"])
    )
else:
    save_low_qual = False

## --------------------------------------------------------------------------------------------------
## removing duplicates
remove_duplicates = recursive_get_and_test(
    ["remove_duplicates", "run"], ["markduplicates", "dedup", "False"]
)

if remove_duplicates == "dedup" and not PAIRED_END:
    LOGGER.warning(
        "WARNING: 'DeDup' is not recommended for single-end reads (parameter config[remove_duplicates][run])!"
    )


## --------------------------------------------------------------------------------------------------
## rescaling damage
run_damage_rescale = str2bool(
    recursive_get_and_test(["damage_rescale", "run"], ["False", "True"])
)
if run_damage_rescale and recursive_get(["damage", "run"], "False") != "mapDamage":
    LOGGER.error(
        "ERROR: To use config[damage_rescale][run] the parameter config[damage][run] has to be set to 'mapDamage'!"
    )
    sys.exit(1)


## --------------------------------------------------------------------------------------------------
## realigning
run_realign = str2bool(recursive_get_and_test(["realign", "run"], ["True", "False"]))


## --------------------------------------------------------------------------------------------------
## recomputing md-flag
run_compute_md = str2bool(
    recursive_get_and_test(["compute_md", "run"], ["True", "False"])
)


##########################################################################################
##  ANALYSES
##########################################################################################
## damage
run_damage = recursive_get_and_test(
    ["damage", "run"], ["False", "bamdamage", "mapDamage"]
)

## sex inference
run_sex_inference = []
for genome in GENOMES:
    if str2bool(
        recursive_get_and_test(["sex_inference", genome, "run"], ["False", "True"])
    ):
        run_sex_inference = run_sex_inference + [genome]
        set_sex_inference(genome)

## test if the specified chromosomes are valid


## depth
run_depth = []
for genome in GENOMES:
    if str2bool(recursive_get_and_test(["depth", genome, "run"], ["False", "True"])):
        run_depth = run_depth + [genome]
        read_depth(genome)


## imputation (is assumed to be run ONLY on the first specified reference GENOMES!!!)
run_imputation = []
for genome in GENOMES:
    if str2bool(recursive_get_and_test(["imputation", "run"], ["False", "True"])):
        run_imputation = run_imputation + [genome]



##########################################################################################
##  STATISTICS
##########################################################################################
## By default he stats are computed on the mapped bam files. However, one can pass pre-computed bam files to use the stats feature of
## mapache using the paramter 'bam_list'. In this later case only on the specified bam fiels the stats are comouted.
run_qualimap = str2bool(
    recursive_get_and_test(["stats", "qualimap"], ["False", "True"])
)

run_multiqc = str2bool(recursive_get_and_test(["stats", "multiqc"], ["False", "True"]))


##########################################################################################
include: "rules/index.smk"
include: "rules/stats.smk"
include: "rules/fastq.smk"
include: "rules/library.smk"
include: "rules/sample.smk"
include: "rules/imputation_glimpse.smk"


report: "report/workflow.rst"


##########################################################################################
## OUTPUT FILES
##########################################################################################
# -----------------------------------------------------------------------------#
## get all final bam files
final_bam = get_final_bam_files()
final_bam_low_qual = get_final_bam_low_qual_files()
final_external_bam = get_final_external_bam_files()


# -----------------------------------------------------------------------------#
## get all final stat files
qualimap_files = get_qualimap_files()
multiqc_files = get_multiqc_files()
sex_files = get_sex_files()
stat_csv = get_stat_csv_files()
stat_plot = get_stat_plot_files()


# -----------------------------------------------------------------------------#
## get all stat files which have to be computed during mapping
fastqc = get_fastqc_files()
samtools_stats = get_samtools_stats_files()
lengths = get_length_files()
idxstats = get_idxstats_files()
damage_files = get_damage_output()


# -----------------------------------------------------------------------------#
## get the minimal final summary stats
stats_mapping_checkpoint = [
    fastqc,
    samtools_stats,
    lengths,
    idxstats,
    sex_files,
    damage_files,
]


final_stats = [
    stat_csv,
    qualimap_files,
    multiqc_files,
]
# -----------------------------------------------------------------------------#

final_stat_figures = [damage_files, stat_plot]


## --------------------------------------------------------------------------------------------------
##########################################################################################
## VERBOSE LOG
##########################################################################################
## print a summary of the contents
if VERBOSE:
    write_log()


##########################################################################################
## STARTING RULES
##########################################################################################
localrules:
    all,
    dag,
    mapping,  ## executed locally on a cluster


## rules all
rule all:
    """
    Computes all
    """
    input:
        final_bam,
        final_external_bam,
        final_bam_low_qual,
        final_stat_figures,
        final_stats,
        samtools_stats,
        stats_mapping_checkpoint,
        get_imputation_files(),
        get_imputation_plots(),
    message:
        "--- RUNNING ALL"


## rules dag (just pipeline)
rule dag:
    """
    Computes just the mapping (used to get a DAG with the relevant steps)
    """
    input:
        final_bam,
        final_external_bam,
        final_bam_low_qual,
        get_imputation_files(),
    message:
        "--- RUNNING DAG"


rule mapping:
    """
    Perfomrs the mapping and computes all stats which are not anymore able to be comouted later (if temporal fiels are used)
    """
    input:
        final_bam,
        final_external_bam,
        final_bam_low_qual,
        stats_mapping_checkpoint,
        get_imputation_files(),
    message:
        "--- RUNNING MAPPING"


# -----------------------------------------------------------------------------#


rule only_stats:
    input:
        get_imputation_files_external(),


rule stats:
    input:
        get_qualimap_files(),
        get_sex_files(),
        get_imputation_files(),


## imputation
rule imputation:
    input:
        get_imputation_files(),


##########################################################################################
onsuccess:
    LOGGER.info("Wow, 'mapache' finished successfully!")
    LOGGER.info(
        "=> To generate the Snakemake report: run 'snakemake --report report.html'."
    )
    shell("cat {log} > snakemake.run.log")
    email = recursive_get(["email"], "")
    if os.path.exists(f"{RESULT_DIR}/verbose.touch"):
        os.remove(f"{RESULT_DIR}/verbose.touch")
    if email != "":
        Logger.info(f"Sending email to {email}")
        shell("mail -s \"'Mapache' finished successfully\" {email} < {log}")


onerror:
    LOGGER.error("'Mapache' finished with error(s), log stored in 'snakemake.run.log'")
    shell("cat {log} > snakemake.run.log")
    email = recursive_get(["email"], "")
    if os.path.exists(f"{RESULT_DIR}/verbose.touch"):
        os.remove(f"{RESULT_DIR}/verbose.touch")
    if email != "":
        LOGGER.info(f"Sending email to {email}")
        shell("mail -s \"'Mapache' finished with error(s)\" {email} < {log}")
